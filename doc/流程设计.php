<?php
[数据存储]
redis中            
    "用户数据"
        备注:可单独开一个redis进程存放
        优化:把用户ID放在前面可方便做分布式存储,具体情况还要看用户ID.如果不放前面,自己用算法做哈希,其实也不麻烦
        数据结构:hash
            client_'用户id' = {
                status = 序列化([
					#最后一次弹窗时间
					last_pop = timestamp(),
					#当日日期
					date = date(),
					#当日标准弹窗次数
					today_std_pop_times = int,
					#当日标准弹窗次数
					today_content_pop_times = int
				]),
                #用户与标准弹窗关系列表
                user_std_pop = 序列化([
                        {内容id,弹出次数},
                        {内容id2,弹出次数},
                    ]),
                #用户与内容弹窗关系列表
                user_content_pop = 序列化([
                        {内容id,弹出次数},
                        {内容id2,弹出次数},
                    ])
            }
        
    "标准弹窗"
        数据结构:hash
            std_pop = {
                'ID' = 序列化({内容})
            }
    
    "内容弹窗"
        数据结构:hash
            content_pop = {
                'ID' = 序列化({内容})
            }
    
    
    "配置信息"
        数据结构:hash
            config={
                #请求间隔时间
                '' = 'v'
                #弹窗间隔时间
                #
            }

    
mysql中
    "用户信息"
    "标准弹窗" url
    "内容弹窗" 文字，图片url，类型，应用id，模板ID

文本中
    "弹窗日志"
        数据结构
            时间,弹窗内容ID,用户ID,本内容的第N次,本日的第N次


[用户访问]
	所有的访问刚进入时的逻辑
	检查userid
	if 如果用户不存在
		初始化用户（测试通过）
	else
		刷新用户数据
		-重点：不能用简单刷新，要注意弹窗内容和人数的绑定关系(测试通过)


	定时请求弹窗信息 #此流程对标准弹窗和内容弹窗同样有效
        //检查时间
        if 查看"用户的最后一次弹窗时间",如果记录了上次弹窗时间
            if 比较"弹窗时间",如果不需要弹 （测试通过）
                return 返回空
		if 如果弹窗总次数已到最大，（测试通过）
			return 不弹
		//读取内容
		读取排序好的弹窗内容
		读取已弹出的记录
		//检查
		if 检查是否有可用的弹窗内容,如果有
			遍历所有弹窗内容
				//日期，由定时脚本清理过了
				//时间（测试通过）
				if 如果start_time和end_time超出范围
						continue;
				//国家（测试通过）
				if 如果有国家限制
					if 国家不匹配
						continue;
				//国家（测试通过）
				if 如果有语言限制
					if 国语言匹配
						continue;
				//广告最大次数（测试通过）
				if 如果有最大弹出次数
					if 已经达到最大弹出次数
						continue;
				//人数限制（测试通过）
				if 如果有人数限制
					if 如果没有和它匹配过
						if 如果它匹配的弹出人数已满
							continue;
						//else  如果匹配人数没满，可以弹，但不进行匹配，匹配在回调的时候做
					//else 如果匹配过，可以弹，因为最大次数已经在上面匹配过了
				
				
				记录"弹窗日志"（测试通过）
					return 弹窗内容
			//如果没有匹配的数据
			return 返回空
				
			//nginx自动记录访问日志    
        
    弹窗信息反馈 #此流程对标准弹窗和内容弹窗同样有效
        更新"用户数据"和"弹窗数据"中的弹窗次数（测试通过）
		if 弹窗内容有人数限制
			增加弹窗的匹配人数（测试通过）
            
[后台]
    编辑（测试通过）
        添加或修改信息
        -需要刷新排顺序列表，刷新方法，在RefreshPopModel中
		-在刷新列表时，会同步所有的mysql数据到redis中，一下子刷新所有数据
		-如果结束时间是00:00,表示不限制时间
		-修改时，要保留旧的弹出次数(poped_times)和绑定人数(people_count)
    
	修改配置文件 （测试通过）
        修改redis中的配置
		
	定时任务
		刷新弹窗信息，(测试通过)
		用户入库，(测试通过)
    
    报表
		先把数据插入到redis中，再同步进mysql表中，然后在mysql表中做查询
        
[数据接口]
文档在 pop控制器中


[业务流]
//从后台开始
添加修改弹窗-》存入redis,redis中建立排序列表


//从用户开始
用户访问-》添加用户-》检查规则，是否可以发起弹窗-》
查找弹窗，把数据和已弹的去重，如果有可用的数据-》不更新次数，但要记录一个日志，返回数据




		
		